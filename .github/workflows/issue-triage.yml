name: Issue Triage

on:
  issues:
    types: [opened]

permissions:
  issues: write
  models: read

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage issue with GitHub Models
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title;
            const body = issue.body || '';

            const availableLabels = [
              { name: 'bug', description: 'Confirmed or reported bugs — something is broken or behaving unexpectedly' },
              { name: 'feature', description: 'Feature requests, enhancements, or new capabilities' },
              { name: 'question', description: 'Usage questions, unclear reports, or general inquiries' },
              { name: 'waiting-for-input', description: 'Needs more info from reporter — missing version, repro steps, or details' },
              { name: 'area/cron', description: 'Cron expression parsing, validation, or evaluation (CronExpression, IsValidExpression, GetTimeAfter, IsSatisfiedBy)' },
              { name: 'area/triggers', description: 'Trigger state management, fire-time calculation, misfire handling, or trigger lifecycle' },
              { name: 'area/adojobstore', description: 'ADO.NET job store persistence (SQL Server, PostgreSQL, MySQL, Oracle, SQLite, JobStoreTX)' },
              { name: 'area/ramjobstore', description: 'In-memory RAMJobStore' },
              { name: 'area/clustering', description: 'Clustered scheduler — concurrent execution, recovery, locking, deadlocks across nodes' },
              { name: 'area/dst', description: 'Daylight saving time transition issues — triggers firing unexpectedly around clock changes' },
              { name: 'area/di', description: 'Dependency injection, IServiceProvider, hosted service, AddQuartz, or IServiceCollection configuration' },
              { name: 'documentation', description: 'Documentation errors or improvements' },
              { name: 'performance', description: 'Performance, scalability, or resource usage issues' },
              { name: 'high-impact', description: 'Affects many users, causes data loss, job duplication, deadlocks, or scheduler stalls' },
              { name: 'low-hanging-fruit', description: 'Easy to fix — small scope, clear solution, good for first-time contributors' }
            ];

            const labelList = availableLabels.map(l => `- "${l.name}": ${l.description}`).join('\n');

            const prompt = `You are triaging issues for Quartz.NET, a .NET enterprise job scheduling library.

            Given the issue below, select the appropriate labels from the available list.

            Rules:
            - Always pick exactly ONE type label: "bug", "feature", or "question".
            - Pick all relevant "area/*" labels (zero or more).
            - Add "waiting-for-input" if the issue lacks a version number, reproduction steps, or enough detail to diagnose.
            - Add "high-impact" only for issues causing data loss, job duplication, deadlocks, or scheduler stalls affecting many users.
            - Add "low-hanging-fruit" only for clearly small, well-defined fixes.
            - Add "documentation" for docs-only issues.
            - Add "performance" for performance/scalability concerns.
            - If the reporter seems confused about expected behavior or is asking how to use the library, prefer "question" over "bug".
            - DST issues: look for mentions of time zone changes, clock adjustments, spring/fall transitions, or triggers firing non-stop.
            - Clustering issues: multiple scheduler nodes, DisallowConcurrentExecution across nodes, database lock contention.
            - Cron issues: CronExpression, IsValidExpression, GetTimeAfter, IsSatisfiedBy, monthly/weekday edge cases.

            Available labels:
            ${labelList}

            Issue title: ${title}

            Issue body:
            ${body.substring(0, 3000)}

            Respond with ONLY a JSON array of label name strings, e.g. ["bug", "area/cron", "high-impact"]. No explanation.`;

            const response = await fetch('https://models.github.ai/inference/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`
              },
              body: JSON.stringify({
                model: 'openai/gpt-4o-mini',
                messages: [
                  { role: 'system', content: 'You are an issue triage assistant. Respond only with a JSON array of label strings.' },
                  { role: 'user', content: prompt }
                ],
                temperature: 0.1
              })
            });

            if (!response.ok) {
              const err = await response.text();
              core.warning(`GitHub Models API returned ${response.status}: ${err}`);
              return;
            }

            const result = await response.json();
            const content = result.choices?.[0]?.message?.content?.trim();

            if (!content) {
              core.warning('No response from model');
              return;
            }

            let labels;
            try {
              labels = JSON.parse(content);
            } catch (e) {
              // Try to extract JSON array from the response
              const match = content.match(/\[.*\]/s);
              if (match) {
                labels = JSON.parse(match[0]);
              } else {
                core.warning(`Could not parse model response: ${content}`);
                return;
              }
            }

            const validLabelNames = availableLabels.map(l => l.name);
            const filteredLabels = labels.filter(l => validLabelNames.includes(l));

            if (filteredLabels.length === 0) {
              core.warning('No valid labels identified by model');
              return;
            }

            core.info(`Applying labels: ${filteredLabels.join(', ')}`);

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: filteredLabels
            });
